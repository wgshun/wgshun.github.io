<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[《PlaneNet-单幅RGB图像的分段平面重建》论文中英文对照解读]]></title>
    <url>%2F2019%2F04%2FPlaneNet-translation%2F</url>
    <content type="text"><![CDATA[PlaneNet: Piece-wise Planar Reconstruction from a Single RGB ImagePlaneNet：单幅RGB图像的分割平面重建论文地址：https://arxiv.org/pdf/1804.06278.pdf代码地址：https://github.com/art-programmer/PlaneNet Abstract论文摘要EN: This paper proposes a deep neural network (DNN) for piece-wise planar depthmap reconstruction from a single RGB image. While DNNs have brought remarkable progress to single-image depth prediction, piece-wise planar depthmap reconstruction requires a structured geometry representation, and has been a difficult task to master even for DNNs. The proposed end-to-end DNN learns to directly infer a set of plane parameters and corresponding plane segmentation masks from a single RGB image. We have generated more than 50,000 piece-wise planar depthmaps for training and testing from ScanNet, a largescale RGBD video database. Our qualitative and quantitative evaluations demonstrate that the proposed approach outperforms baseline methods in terms of both plane segmentation and depth estimation accuracy. To the best of our knowledge, this paper presents the first end-to-end neural architecture for piece-wise planar reconstruction from a single RGB image. Code and data are available at https://github.com/art-programmer/PlaneNet.CH: 本篇论文提出了一种深度神经网络（DNN）去完成单幅图像的分割平面深度图重建任务。虽然DNN在单幅图像上的深度预测取得了显著的进步，但是分割平面深度图重建需要一个结构化的几何表示，即使对于DNN也是很难解决的一个任务。提出的这个端到端的DNN直接从单幅RGB图像中推算出一套平面参数和对应的平面分割掩膜。我们从 ScanNet 生成了超过50000张的分割平面深度图用于训练和测试，ScanNet 是一个大型的 RGBD 视频数据集。我们的定性和定量评估表明我们提出的这个方法在平面分割和深度估计的精度方面都比基础的方法效果要好。据我们所知，这篇论文提出的端到端神经网络结构是第一个用来解决单幅RGB图像的分割平面重建问题的神经网络。代码和数据均在GitHub：https://github.com/art-programmer/PlaneNet 1. Introduction1. 前言EN: Human vision has extraordinary perceptual power in understanding advanced scene structures. Looking at a typical indoor scene (for example, Figure 1), we can immediately parse the room into a few major planes (for example, floors, walls, and ceilings), sense the main surface of the furniture, or identify the surface of a horizontal tabletop. Segmental planar geometry understanding will be key to many applications in emerging areas such as robotics or augmented reality (AR). For example, the robot needs to identify the extent of the floor used to plan the move, or the desktop split for placing the object. In AR applications, planar surface inspection is becoming the basic building block for placing virtual objects on the desktop, replacing floor textures or hanging artwork on walls for internal remodeling. A fundamental problem in computer vision is the development of a computational algorithm that masters similar perceptions to implement such an application.CH: 人类视觉在理解高级别场景结构方面有着非凡的感知能力。看一个典型的室内场景（比如图一），我们能立即将这个房间分析成一些主要的平面（比如墙，地板，天花板），感知家具的主要表面和水平桌面的表面。分割平面的几何理解对一些新兴领域的许多应用起到了很关键的作用，比如机器人或虚拟现实（AR）。例如，机器人需要检测用于移动的地板的范围，或者在放置物体时需要分割桌面。在AR应用中，需要往桌面上放置虚拟的物体，更换地板的样式或对墙上的艺术品进行内部改建，这时的检测平面的表面就是一个基础的模块。计算机视觉中一个基础的问题是一个能解决相似感知问题的几何算法来实现这样的应用。 EN: With the proliferation of deep neural networks, single image depth map inference and room layout estimation have been active areas of research. However, to our surprise, little attention has been paid to the study of segmental planar depth map reconstruction, which mimics this remarkable human perception in a general form. The main challenge is that segmented planar depth maps require a structured geometric representation (ie, a set of planar parameters and their segmentation masks). In particular, we do not know the number of planes to infer, and the order of the planes that are returned in the output feature vector, making the task even challenging for deep neural networks.CH: 随着深度神经网络的兴起，单幅图像的深度图和房间布局的推断一直是搞研究的活跃领域。然而，我们感到比较惊讶的是，分割平面深度图重建这一方面很少有人关注，这一方面一般来说是模仿了人类的这种非凡的感知能力。其中比较主要的挑战是分割平面深度图需要一个结构化的几何表示（i.e.平面参数的集合和它们的分割掩膜）。尤其是，我们不知道需要分割的平面数量，以及平面在输出特征向量中的顺序，完成这些任务对深度神经网络来说也很有挑战。 EN: This paper proposes a novel deep neural architecture “PlaneNet” that learns to directly produce a set of plane parameters and probabilistic plane segmentation masks from a single RGB image. Following a recent work on point-setgeneration, we define a loss function that is agnostic to the order of planes. We further control the number of planes by allowing probabilistic plane segmentation masks to be all 0. The network also predicts a depthmap at non-planar surfaces, whose loss is defined through the probabilistic segmentation masks to allow back-propagation. We have generated more than 50,000 piece-wise planar depthmaps from ScanNet as ground-truth by fitting planes to 3D points and projecting them to images. Qualitative and quantitative evaluations show that our algorithm produces significantly better plane segmentation results than the current state-ofthe-art. Furthermore, our depth prediction accuracy is on-par or even superior to the existing single image depth inference techniques that are specifically trained for this task.CH: 本篇论文提出了一个新的深度神经网络结构“PlaneNet”，它通过学习训练直接从单幅RGB图像中得到一组平面参数和对应的平面分割掩膜。在最近的一项点集分割工作中，我们定义了一个跟平面顺序无关的损失函数。我们通过允许概率性的平面分割掩膜为0来进一步的控制平面的数量。这个网络结构还预测非平面处的深度图，这个损失是通过概率分割掩膜定义的，可以进行反向传播。我们通过拟合平面到3D点上，并且将它们投射到图像中，从 ScanNet 数据集中生成了超过50000张分段平面深度图作为真实样本。定性和定量的评估标准表明：我们的算法的平面分割结果相比当下流行的技术，有显著的提升。此外，我们的深度预测精度甚至要比当下专门针对此任务的算法更优秀。 2. Related work2. 相关工作EN: Multi-view piece-wise planar reconstruction. Piece-wise planar depthmap reconstruction was once an active research topic in multi-view 3D reconstruction. The task is to infer a set of plane parameters and assign a plane ID to each pixel. Most existing methods first reconstruct precise 3D points, perform plane-fitting to generate plane hypotheses, then solve a global inference problem to reconstruct a piece-wise planar depthmap. Our approach learns to directly infer plane parameters and plane segmentations from a single RGB image.CH: 多视图分段平面重建。分段平面深度图重建曾经在多视图3D重建中的活跃研究领域。这个任务是推断一组平面参数并且给每个像素分配一个平面ID。目前大部分的算法都是首先重建精确的3D点集，拟合平面去生成假设平面，然后求解一个全局的推理问题去重建一个分段平面深度图。我们的方法通过学习训练直接从单幅RGB图像中得到一组平面参数和对应的平面分割掩膜。 EN: Learning based depth reconstruction. Saxena et al. pioneered a learning based approach for depthmap inference from a single image. With the surge of deep neural networks, numerous CNN based approaches have been proposed. However, most techniques simply produce an array of depth values (i.e., depthmap) without plane detection or segmentation. More recently, Wang et al. enforce planarity in depth (and surface normal) predictions by inferring pixels on planar surfaces. This is the closest work to ours. However, they only produce a binary segmentation mask (i.e., if a pixel is on a planar surface or not) without plane parameters or instance-level plane segmentation.CH: 基于自学习的深度重建。Saxena 等人针对单幅图像的深度图推断提出了一个基于自学习的方法。随着深度神经网络的兴起，出现了许多基于CNN的方法。但是，大部分的方法只是简单生成一组深度数值（i.e.深度图）而没有平面的检测与分割。最近，Wang等人通过计算平面上的像素信息，在深度信息（以及表面法线）预测中执行平面化操作。这是跟我们最接近的方法。然而，他们仅仅生成一个二进制的分割掩膜（i.e.一个像素是否在平面上），而没有平面参数或实例级别的平面分割。 EN: Layout estimation. Room layout estimation also aims at predicting dominant planes in a scene (e.g., walls, floor, and ceiling). Most traditional approaches rely on image processing heuristics to estimate vanishing points of a scene, and aggregate low-level features by a global optimization procedure. Besides low-level features, high-level information has been utilized, such as human poses or semantics. Attempts have been made to go beyond room structure, and predict object geometry. However, the reliance on hand-crafted features makes those methods less robust, and the Manhattan World assumption limits their operating ranges. Recently, Lee et al. proposed an end-to-end deep neural network, RoomNet, which simultaneously classifies a room layout type and predicts corner locations. However, their framework is not applicable to general piece-wise planar scenes.CH: 房间布局估计。房间布局的估计也是针对一个场景中的主要平面进行预测的。（e.g.墙，地板和天花板）大部分传统的算法依靠图像的启发式处理去估算场景中的消隐点，并通过一个全局的优化程序聚合底层特征。除了底层特征，还使用到了一些高级信息，比如：人类的姿态和语义。尝试越过房间的结构来预测目标的几何结构。但是，人工选择的特征使得这些方法的稳健性比较低，曼哈顿世界的假设也限制了它们的操作范围。最近，Lee等人，提出了一个端到端的深度神经网络 RoomNet，它能同时分类房间的布局类型和预测角落的位置。但是，他们的框架不适用与一般情况下的分段平面场景。 EN: Line analysis. Single image 3D reconstruction of line drawings date back to the 60s. The earliest attempt is probably the Robert’s system, which inspired many follow-up works. In real images, extraction of line drawings is challenging. Statistical analysis of line directions, junctions, or image segments have been used to enable 3D reconstruction for architectural scenes or indoor panoramas. Attributed grammar was used to parse an image into a hierarchical graph for 3D reconstruction. However, these approaches require hand-crafted features, grammar specification, or algorithmic rules. Our approach is purely data-driven harnessing the power of deep neural networks.CH: 线分析。单幅线条图像的3D重建可以追溯到60年代。最早的尝试大概是 Robert 的系统，它启发了许多后面的工作。在实际的图像中，线条图的提取有不小的挑战性。线向统计分析，交叉点和图像分割已经被用于建筑场景和室内全景图的3D重建。Attributed grammar 将图像解析成分层图用于3D重建。但是，这些传统的算法需要人工选取的特征，grammar specification, 或算法规则。我们的方法纯粹靠数据驱动的深度神经网络的力量。 3. PlaneNet3. PlaneNetEN: We build our network on the Extended Residual Network (DRN) (see Figure 2), which is a flexible framework for global tasks (eg image classification) and pixel prediction tasks (eg semantic segmentation). Given the high-resolution final feature map from the DRN, we make three output branches for the three prediction tasks.CH: 我们基于 Extended Residual Network (DRN) 来构建我们的网络，（图二所示）DRN是针对全局性任务（e.g.图片分类）和像素预测任务（e.g.语义分割）的一个灵活框架。针对DRN最终输出的高分辨率的特征图，我们对于三个不同的预测任务提供了三个分支。EN: Plane parameters: For each scene, we predict a fixed number ($K$) of planar surfaces $S = {S_1, · · · S_K}$. Each surface $S_i$ is specified by the three plane parameters $P_i$ (i.e., encoding a normal and an offset). We use $D_i$ to denote a depth image, which can be inferred from the parameters $P_i$ .The depth value calculation requires camera intrinsic parameters, which can be estimated via vanishing point analysis, for example. In our experiments, intrinsics are given for each image through the database information.CH: 平面参数。对于每个场景，我们预测的平面 $S = {S_1, · · · S_K}$ 数量是固定的 $K$。每个平面 $S_i$ 都通过三个平面参数 $P_i$ 指定。（i.e.编码法线和偏移量）我们用 $D_i$ 来表示深度图像，它能从参数 $P_i$ 中推算出来。深度值得推算需要相机内置参数，而相机内置参数可以通过消隐点分析来估算。但在我们的实验中相机内置参数是通过数据集每张图像的信息提供的。 EN: Non-planar depthmap: We model non-planar structures and infer its geometry as a standard depthmap. With abuse of notation, we treat it as the $(K+1)^{th}$ surface and denote the depthmap as $D_{K+1}$. This does not explain planar surfaces.CH: 非平面深度图：我们对非平面结构进行建模处理，并将它的几何结构推断为标准的深度图。用符号表示的话，我们把平面表示为 $(K+1)^{th}$ ，把对应的深度图表示为 $D_{K+1}$。但是这个不能用来解释平面信息。 EN: Segmentation masks: The last output is the probabilistic segmentation masks for the $K$ planes $(M_1, · · · M_K)$ and the non planar depthmap $(M_{K+1})$.CH: 分割掩膜：最后的输出是第 $K$ 个平面 $(M_1, · · · M_K)$ 的分割掩膜和对应的非平面深度图 $(M_{K+1})$ 。 EN: In summary, the network predicts 1) plane parameters $(P1, ···, PK)$, 2) non-planar depth maps $(D_{K + 1})$, and 3) probability split masks $(M_1, ···, M_{K + 1})$. We now explain more details and loss functions for each task.CH: 概括起来，这个网络解决了三个任务：1）平面参数 $(P1, ···, PK)$，2）非平面深度图 $(D_{K + 1})$，3）概率分割掩膜 $(M_1, ···, M_{K + 1})$。下面详细说明每个任务的更多细节和损失函数。 3.1. Plane parameter branch3.1. 平面参数分支EN: The plane parameter branch starts with a global average pooling to reduce the feature map size to 1x1, followed by a fully connected layer to produce $K×3$ plane parameters. We do not know the number of planes as well as their order in this prediction task. By following prior works, we predict a constant number $(K)$ of planes, then allow some predictions to be invalid by letting the corresponding probabilistic segmentation masks to be 0. Our ground-truth generation process (See Sect. 4) produces at most 10 planes for most examples, thus we set $K = 10$ in our experiments. We define an order-agnostic loss function based on the Chamfer distance metric for the regressed plane parameters: L^P=\sum_{i=1}^{K^*}min_{j\in[1,K]}\Vert P_i^*-P_j \Vert_2^2The parameterization $P_i$ is given by the 3D coordinate of the point that is closest to the camera center on the plane. $P^∗_i$ is the ground truth. $K^∗$ is the number of ground-truth planes.CH: 平面参数分支从一个全局平均 pooling 开始，将特征图的尺寸变成 1x1，紧接着，通过一个全连接层生成 $K×3$ 的平面参数。我们不知道平面的数量也不知道在这个预测任务中的顺序。通过遵循之前的工作，我们预测的平面数量为 $K$，然后通过使对应的概率分割掩膜为 0，让一些预测的平面无效。我们的大部分真实实例都可以生成十个左右的平面，（见第四节）因此在我们的实验中设置 $K=10$。我们基于倒角距离度量针对平面参数的回归定义了一个与顺序无关的损失函数：L^P=\sum_{i=1}^{K^*}min_{j\in[1,K]}\Vert P_i^*-P_j \Vert_2^2参数 $P_i$ 是根据平面上最靠近相机中心的点的3D坐标得到的。$P^∗_i$ 是真实实例。$K^∗$ 是真实实例中平面的数量。 3.2. Plane segmentation branch3.2. 平面分割分支EN: The branch begins with a pyramid pool module followed by a convolutional layer to produce a $K + 1$ channel likelihood map for planar and non-planar surfaces. We added a dense conditional random field (DCRF) module based on the fast inference algorithm proposed by Krahenbuhl and Koltun, and jointly trained the DCRF module and the previous layer with Zheng et al. We set the average number of field iterations to 5 during training and set it to 10 during the test. For simplicity, the bandwidth of the bilateral filter is fixed. We use standard softmax cross entropy loss to supervise segmentation training: L^M=\sum_{i=1}^{K+1}\sum_{p \in I}(1(M^{*(p)}=i)log(1-M_i^{(p)}))The internal summation is over the image pixels $(I)$, where $M^{(p)}_i$ denotes the probability of pixel $p$ belonging to the $i^{th}$ plane. $M^{∗(p)}$ is the ground-truth plane-id for the pixel.CH: 这个分支以一个金字塔池化模块开始，紧接着通过一个卷积层生成平面和非平面表面 $K+1$ 通道的极大似然图。我们在 Krahenbuhl 和 Koltun 提出的快速推理算法的基础上添加了一个密集条件随机场（DCRF）模块，并且和 Zheng 等人共同训练这个 DCRF 模块和先前的层。我们在训练期间设置平均场迭代为5，在测试期间设置为10.为简单起见，双边滤波器的带宽是固定的。我们用标准的 softmax 交叉熵损失函数来监督分割训练：L^M=\sum_{i=1}^{K+1}\sum_{p \in I}(1(M^{*(p)}=i)log(1-M_i^{(p)}))当 $M^{(p)}_i$ 表示像素 $p$ 属于平面 $i^{th}$ 的概率时，里面的求和是对图像像素 $(I)$ 的求和。$M^{∗(p)}$ 是像素在真实实例上所属的平面 id。 3.3. Non-planar depth branch3.3. 非平面深度分支EN: The branch shares the same pyramid pooling module, followed by a convolution layer to produce a 1-channel depthmap. Instead of defining a loss specifically for non-planar regions, we found that exploiting the entire ground-truth depthmap makes the overall training more effective. Specifically, we define the loss as the sum of squared depth differences between the ground-truth and either a predicted plane or a non-planar depthmap, weighted by probabilities:L^D=\sum_{i=1}^{K+1}\sum_{p\in I}(M_i^{(p)}(D_i^{(p)}-D^{*(p)})^2)$$$D_i^{(p)}$ denotes the depth value at pixel p, while $D^{*(p)}$ is the ground truth depth value. ***CH:*** 这个分支与平面分割分支分享使用同一个金字塔池化模块，然后通过一个卷积层生成1通道的深度图。我们发现使用全部的真实实例深度图来进行训练比单独定义一个非平面区域的损失要更有效。因此，我们将损失定义为真实实例与预测平面或非平面深度图之间深度差的平方和，并由概率进行加权：L^D=\sum_{i=1}^{K+1}\sum_{p\in I}(M_i^{(p)}(D_i^{(p)}-D^{(p)})^2)$$当$D^{(p)}$ 表示真实实例的深度值时，$D_i^{(p)}$ 表示在像素 $p$ 的深度值。 4. Datasets and implemenation details4. 数据集和网络实现细节EN: We have generated 51,000 ground-truth piece-wise planar depthmaps (50,000 training and 1,000 testing) from ScanNet, a large-scale indoor RGB-D video database. A depthmap in a single RGB-D frame contains holes and the quality deteriorates at far distances. Our approach for ground-truth generation is to directly fit planes to a consolidated mesh and project them back to individual frames, while also exploiting the associated semantic annotations.CH: 我们从 ScanNet（一个大型室内的 RGB-D 视频数据库）中生成了 51,000 张分段平面深度图作为真实样本（50,000张训练，1,000张预测）。单幅RGB-D图像的深度图包含 holes，而且图像内容距离比较远的效果也会变坏。我们生成真实实例的方法是将平面拟合到统一的网格中，并将他们投射回单个图像帧，同时还利用了相关的语义注释。 EN: Specifically, for each sub mesh-models of the same semantic label, we treat mesh-vertices as points and repeat extracting planes by RANSAC with replacement. The inlier distance threshold is $5cm$, and the process continues until 90% of the points are covered. We merge two (not necessarily adjacent) planes that span different semantic labels if the plane normal difference is below $20^◦$ , and if the larger plane fits the smaller one with the mean distance error below $5cm$. We project each triangle to individual frames if the three vertices are fitted by the same plane. After projecting all the triangles, we keep only the planes whose projected area is larger than 1% of an image. We discard entire frames if the ratio of pixels covered by the planes is below 50%. For training samples, we randomly choose 90% of the scenes from ScanNet, subsample every 10 frames, compute piecewise planar depthmaps with the above procedure, then use the final random sampling to produce 50,000 examples. The same procedure generates 1,000 testing examples from the remaining 10% of the scenes.CH: 明确来说，对于相同语义标签的每个子网格模型，我们将网格顶点视为 points，并通过 RANSAC 算法重复提取平面。这个内部距离的阈值为 $5cm$，并且这个过程会持续到 points 的百分之九十被覆盖。如果两个跨越不同语义标签的平面的平面法线差异小于$20^◦$ 并且大平面拟合小平面时平均距离误差小于 $5cm$，就合并这两个平面。（不一定相邻）如果三个网格顶点拟合同一个平面，就把三个顶点投射到单独的坐标系中。投射完所有的顶点，只保留投射区域大于原图面积百分之一的平面。如果所有的平面像素覆盖比小于百分之五十，就丢弃所有的平面。我们从 ScanNet 中随机选取百分之九十的场景，每十帧采样一次，使用上述流程生成分段平面深度图，然后用随机采样选出50,000个样本作为训练集。相同的流程从 ScanNet 剩余的百分之十场景中选出1,000个样本作为测试集。 EN: We have implemented PlaneNet using TensorFlow based on DeepLab . Our system is a 101-layer ResNet with Dilated Convolution, while we have followed a prior work and modified the first few layers to deal with the degridding issue. The final feature map of the DRN contains 2096 channels. We use the Adam optimizer with the initial learning rate set to 0.0003. The input image, the output plane segmentation masks, and the non-planar depthmap have a resolution of 256x192. We train our network for 50 epochs on the 50,000 training samples.CH: 我们基于 DeepLab 的 TensorFlow 实现了 PlaneNet 。我们的方法是有着 Dilated Convolution（扩张卷积）的 101层 Resnet，我们复现了先前的工作，并修改了前几层，为了处理 degridding 的问题。最后输出的 DRN 特征图包括 2096 个通道。我们使用 Adam 优化器设置学习率为 0.0003 来进行网络训练优化。输入图像，输出的平面分割掩膜和非平面深度图的尺寸都为 256x192。我们在 50,000 个训练样本上训练了 50 轮我们的网络。 5. Experimental results5. 实验结果EN: Figure 3 shows the reconstruction results for various scenarios. Our end-to-end learning framework has successfully restored segmented planar and semantically meaningful structures from a single RGB image, such as a floor, wall, desktop or computer screen. We have included more examples in the supplements. We now provide a quantitative assessment of the accuracy of planar segmentation and depth reconstruction for competitive baselines, and then analyze our results more.CH: 图三展示了各种场景的平面重建结果。我们的端到端的学习架构成功的从单幅RGB图像中重建了分段的平面结构和有意义的语义结构，比如：地板，墙面，桌面或电脑屏幕。在补充材料里有更多的实例结果。我们提出了一个针对平面分割和深度图重建的定量评估标准，然后对我们的结果进行更多的分析。EN: Figure 3: Piece-wise planar depthmap reconstruction results by PlaneNet. From left to right: input image, plane segmentation, depthmap reconstruction, and 3D rendering of our depthmap. In the plane segmentation results, the black color shows non-planar surface regions.CH: 图三：PlaneNet 的分段平面深度图重建结果。从左到右：输入图像，平面分割结果，深度图重建结果和深度图的3D渲染结果。在平面分割结果中，黑色显示非平面表面区域。 5.1. Plane segmentation accuracy5.1. 平面分割准确率EN: Piece-wise planar reconstruction from a single RGB image is a challenging problem. While existing approaches have produced encouraging results, they are based on hand-crafted features and algorithmic designs, and may not match against big-data and deep neural network (DNN) based systems. Much better baselines would then be piece-wise planar depthmap reconstruction techniques from 3D points, where input 3D points are either given by the ground truth depthmaps or inferred by a state-of-the-art DNN-based system.CH: 单幅RGB图像的分段平面重建是一个有挑战的问题。虽然现有的方法在这方面已经有了不错的结果，但它们都是基于手动设计的特征的算法，并且可能和基于大数据和深度神经网络的系统不匹配。更好的基准线将来自于3D点的分段平面深度图重建技术，输入3D点，然后将由真实实例的深度图或最先进的DNN系统推测输出。 EN: In particular, to infer depthmaps, we have used a variant of PlaneNet which only has the pixel-wise depthmap branch, while following Eigen et al. to change the loss. Table 1 shows that this network, PlaneNet (Depth rep.), outperforms the current top-performers on the NYU benchmark.CH: 特别是，为了推算深度图，我们使用了 PlaneNet 的变种网络，只保留像素级的深度图分支，然后参考 Eigen 等人的思想去改变损失函数。图一显示 PlaneNet 在 NYU 的基准上是目前最佳的网络。 EN: For piece-wise planar depthmap reconstruction, we have used the following three baselines from the literature.“NYU-Toolbox” is a plane extraction algorithm from the official NYU toolbox that extracts plane hypotheses using RANSAC, and optimizes the plane segmentation via a Markov Random Field (MRF) optimization.Manhattan World Stereo (MWS) is very similar to NYU-Toolbox except that MWS employs the Manhattan World assumption in extracting planes and exploits vanishing lines in the pairwise terms to improve results.Piecewise Planar Stereo (PPS) relaxes the Manhattan World assumption of MWS, and uses vanishing lines to generate better plane proposals. Please see the supplementary document for more algorithmic details on the baselines.CH: 为了对比分段平面深度图重建，我们使用了文献中的三个方法作为比较基准。NYU-Toolbox 是 NYU 官方工具箱中的平面提取算法，使用了 RANSAC 算法提取平面候选区域，然后通过马尔可夫随机场（MRF）来优化平面分割。Manhattan World Stereo (MWS) 与 NYU-Toolbox 很相似，不同之处在于 MWS 在提取平面时用了曼哈顿世界的假设（Manhattan World assumption），并且用成对项中的消失线来改善结果。Piecewise Planar Stereo (PPS) 放宽了曼哈顿世界假设（Manhattan World assumption）对 MWS 的影响，并使用消失线来生成更好的平面候选区域。 EN: Figure 4 shows the evaluation results on two recall metrics. The first metric is the percentage of correctly predicted ground-truth planes. We consider a ground-truth plane being correctly predicted, if one of the inferred planes has 1) more than 0.5 Intersection over Union (IOU) score and 2) the mean depth difference over the overlapping region is less than a threshold. We vary this threshold from 0 to 0.6m with an increment of 0.05m to plot graphs. The second recall metric is simply the percentage of pixels that are in such overlapping regions where planes are correctly predicted. The figure shows that PlaneNet is significantly better than all the competing methods when inferred depthmaps are used. PlaneNet is even better than some competing methods that use ground-truth depthmaps. This demonstrates the effectiveness of our approach, learning to infer piece-wise planar structures from many examples.CH: 图四显示了两个召回指标的评估结果。第一个指标是正确预测的真实实例平面的百分比。我们判断一个真实实例平面预测是否正确的标准是：1）是否有IOU分数大于0.5的平面，2）重叠区域的平均深度差是否小于阈值。我们让这个阈值从0 - 0.6m以0.05m的速度递增来画图。第二个指标是正确预测平面中重叠区域所占的像素百分比。该图显示，在推算深度图指标中 PlaneNet 要优于其他的方法。证明了我们的方法的有效性，从许多实例中学习推算分段平面结构。EN: Figure 4: Plane segmentation accuracy against competing baselines that use 3D points as input. Either ground-truth depthmaps or inferred depthmaps (by a DNN-based system) are used as their inputs. PlaneNet outperforms all the other methods that use inferred depthmaps. Surprisingly, PlaneNet is even better than many other methods that use ground-truth depthmaps.CH: 图四：使用3D点作为输入，平面分割准确率的对比。或者使用真实实例深度图和基于DNN系统推算的深度图作为输入。PlaneNet 要优于其他的方法。出人意料的是，PlaneNet 比一些使用真实实例深度图的方法还要好。 EN: Figure 5 shows qualitative comparisons against existing methods with inferred depthmaps. PlaneNet produces significantly better plane segmentation results, while existing methods often generate many redundant planes where depthmaps are noisy, and fail to capture precise boundaries where the intensity edges are weak.CH: 图五显示了与现有的方法推算出的深度图的定性比较。PlaneNet 生成了更好的平面分割结果，现有的方法会有一些冗余的平面而且深度图会有很多噪音，不能精确的捕捉到平面的边界。EN: Figure 5: Qualitative comparisons between PlaneNet and existing methods that use inferred depthmaps as the inputs. From left to right: an input image, plane segmentation results for existing methods, and PlaneNet, respectively, and the ground-truth.CH: 图五：使用推算的深度图作为输入，PlaneNet 与现有的其他方法的定性比较。从左往右：第一列为输入图像，第二三四列为现有其他方法的平面分割结果，第五列为PlaneNet 的平面分割结果，第六列为真实实例。 5.2. Depth reconstruction accuracy5.2. 深度重建的准确率EN: While the capability to infer a plane segmentation mask and precise plane parameters is the key contribution of the work, it is also interesting to compare against depth prediction methods. This is to ensure that our structured depth prediction does not compromise per-pixel depth prediction accuracy. PlaneNet makes $(K+1)$ depth value predictions at each pixel. We pick the depth value with the maximum probability in the segmentation mask to define our depthmap.CH: 虽然这个工作的关键是预测平面分割掩膜和精确的平面参数，但也能与深度预测方法进行比较。可以确保我们的深度结构化预测不会对每个像素的深度预测精度造成影响。PlaneNet 对每个像素进行了 $(K+1)$ 深度值预测。我们选择分割掩膜中最大概率的深度值来定义深度图。 EN: Depth accuracies are evaluated on the NYUv2 dataset at 1) planar regions, 2) boundary regions, and 3) the entire image, against three competing baselines. Eigen-VGG is a convolutional architecture to predict both depths and surface normals. SURGE is a more recent depth inference network that optimizes planarity. FCRN is the current state-of-the-art single-image depth inference network .CH: 深度精度评估基于 NYUv2 数据集的平面区域，边界区域和整个图像。三个对比网络分别是：Eigen-VGG 是用来预测深度值和平面法线的卷积结构。SURGE 是最新的深度推算网络可以优化平面的。FCRN 是目前最好的单图像推算网络。 EN: Depthmaps in NYUv2 are very noisy and ground-truth plane extraction does not work well. Thus, we fine-tune our network using only the depth loss. Note that the key factor in this training is that the network is trained to generate a depthmap through our piece-wise planar depthmap represen-tation. To further verify the effects of this representation, we have also fine-tuned our network in the standard per-pixel depthmap representation by disabling the plane parameter and the plane segmentation branches. In this version, denoted as “PlaneNet (Depth rep.)”, the entire depthmap is predicted in the $(K + 1)^{th}$ depthmap $(D_{K+1})$.CH: NYUv2 的深度图有很多噪音，并且真实实例的平面提取效果不好。因此，我们只使用深度损失来 fine-tune 我们的网络。注意，训练时候的关键因素是网络经过训练可以通过我们分段平面深度信息表示生成深度图。为了进一步验证这种表示的效果，我们禁用了平面参数和平面分割掩膜两个分支，只 fine-tune 像素的深度图网络分支，这个版本表示为 PlaneNet (Depth rep.)。 EN: Table 1 shows the depth prediction accuracy on various metrics introduced in the prior work. The left five metrics provide different error statistics such as relative difference (Rel) or rooted-mean-square-error (RMSE) on the average per-pixel depth errors. The right three metrics provide the ratio of pixels, for which the relative difference between the predicted and the ground-truth depths is below a threshold. The table demonstrates that PlaneNet outperforms the state of-the-art of single-image depth inference techniques. As observed in prior works, the planarity constraint makes differences in the depth prediction task, and the improvements are more significant when our piece-wise planar representation is enforced by our network.CH: 表一展示了先前工作中用的各种指标的深度预测准确度。左边五个是不同的误差统计，比如：平均像素深度误差的相对偏差（Rel）和均方根误差（RMSE）右边三个是像素所占的比例，对于那些预测的和实际的深度相对误差小于阈值的。该表表明 PlaneNet 要优于目前单图像深度信息推算的最新方法。之前的工作中有观察到，在深度预测任务中，平面约束可以产生积极的影响，当我们的网络强制性执行分段平面表示时，这种影响更加的明显了。 5.3. Plane ordering consistency5.3. 平面顺序的一致性EN: For segment depth map inference, sorting ambiguity is a challenge. We found that PlaneNet automatically learns consistent sorting without supervision, for example, the floor is always returned to the second plane. In Figure 3, the colors in the planar segmentation results are defined by the order of the planes in the network output. While ordering loses consistency for small objects or extreme camera angles, in most cases, major common surfaces such as floors and walls have a consistent ordering.CH: 对于分割深度图的推算，平面的顺序是一个挑战。我们发现 PlaneNet 在没有干预的情况下会自动进行平面排序，例如：识别出来的地板总是被分到第二个平面。图三中，平面分割结果的颜色就由输出的平面顺序决定的。一般情况下，对于墙面，地板这些大的平面，顺序是一致的，只有在一些小平面上会失去一致性。 EN: We have taken advantage of this property and implemented a simple room layout estimation algorithm. More specifically, we look at the reconstruction example and manually select the plane entries that correspond to the ceiling, floor, and left/middle/right walls. For each possible room layout configuration (for example, a configuration with floor, left and middle walls visible), we build a 3D concave shell based on the plane parameters and project it back into the image to generate the room-layout. We measure the configured score by the number of pixels, where the constructed room layout is consistent with the inferred plane segmentation (determined by the winner). We chose the constructed room layout with the best score as our prediction. Figure 6 shows that our algorithm can generate reasonable room layout estimates even if the scene is confusing and contains many occlusion objects. Table 2 shows a quantitative assessment of the NYUv2 303 data set, where our method is comparable to the prior art designed specifically for this task.CH: 根据这样一个特点，我们实现了一个房间布局估计算法，具体来说，我们在重建的实例中手动选择对应的天花板，墙面，地板等平面。对于每个可能的房间布局配置，我们都根据推算的平面参数构建一个3D结构，然后将这个3D结构投影到原图像生成房间的布局配置。在构建的房间布局和推断的平面分割一致时，我们通过像素的数量来衡量预测布局的效果。最后选择具有最佳效果的房间布局作为输出的预测结果。图六显示即使场景很复杂，有许多遮挡对象，我们的算法也能够生成合理的房间布局。表二显示在 NYUv2 303 数据集上，我们的方法与专门针对此任务的方法效果相当。EN: Figure 6: Room layout estimations. We have exploited the ordering consistency in the predicted planes to infer room layouts.CH: 图六：房间布局估计。我们利用预测平面的顺序一致性来预测房间布局。EN: Table 2: Room layout estimations. Quantitative evaluations against the top-performers over the NYUv2 303 dataset.CH: 表二：房间布局估计。在 NYUv2 303 数据集上与其他算法的定性效果比较。 5.4. Failure modes5.4. 不足之处EN: While achieving promising results on most images, PlaneNet has some failure modes as shown in Fig. 7. In the first example, PlaneNet generates two nearly co-planar vertical surfaces in the low-light region below the sink. In the second example, it cannot distinguish a white object on the floor from a white wall. In the third example, it misses a column structure on a wall due to the presence of object clutter. While the capability to infer precise plane parameters is already super-human, there is a lot of room for improvement on the planar segmentation, especially in the absence of texture information or at the presence of clutter.CH: 虽然在很多图像上有不错的效果，但是 PlaneNet 还是有许多不足之处，如图七所示。在第一个例子中，PlaneNet 在一个低光区域产生了两个几乎共面的垂直表面，第二个例子中，没有把白色墙壁和白色物体区分开来，第三个例子中，由于杂乱物体的影响，错过了墙上的列结构。虽然 PlaneNet 在推算平面参数的能力已经时很优秀了，但是在平面分割精度方面还有待提升，尤其是在没有纹理和有杂物的情况下。EN: Figure 7: Typical failure modes occur in the absence of enough image texture cues or at the presence of small objects and clutter.CH: 图七：不足之处在于缺乏纹理或者有小物体遮挡的情况下。 6. Applications6. 应用EN: Structured geometry reconstruction is important for many application in Augmented Reality. We demonstrate two image editing pplications enabled by our piece-wise planar representation: texture insertion and replacement (see Fig. 8). We first extract Manhattan directions by using the predicted plane normals through a standard voting scheme . Given a piece-wise planar region, we define an axis of its UV coordinate by the Manhattan direction that is the most parallel to the plane, while the other axis is simply the cross product of the first axis and the plane normal. Given a UV coordinate, we insert a new texture by alpha-blending or completely replace a texture with a new one. Please see the supplementary material and the video for more AR application examples.CH: 结构化几何重建对于增强现实中的许多应用都非常重要。通过使用我们的分段平面表示：纹理插入和替换，做了两个图像编辑的应用。（见图八）我们首先用一个标准的表决方法通过预测的平面法线来提取曼哈顿方向。给定分段平面分割的区域，我们通过最平行与平面的曼哈顿方向来定义它的 UV 坐标轴，另一个轴是第一个轴和其平面法线的叉乘。给定 UV 坐标轴，我们通过 alpha-blending 插入新的纹理或者完全替换旧纹理。更多实例请参阅补充材料及视频。EN: Figure 8: Texture editing applications. From top to bottom, an input image, a plane segmentation result, and an edited image.CH: 图八：图片纹理编辑应用。 7. Conclusion and future work7. 结论及未来的工作EN: This paper proposes PlaneNet, the first deep neural architecture for piece-wise planar depthmap reconstruction from a single RGB image. PlaneNet learns to directly infer a set of plane parameters and their probabilistic segmentation masks. The proposed approach significantly outperforms competing baselines in the plane segmentation task. It also advances the state-of-the-art in the single image depth prediction task. An interesting future direction is to go beyond the depthmap framework and tackle structured geometry prediction problems in a full 3D space.CH: 本论文提出了第一个用于单幅图像重建分段平面深度图的深度神经网络-PlaneNet。PlaneNet 直接推断平面参数及其分割掩膜。这个方法不仅在此任务中明显的优于目前的其他方法，还推动了单一图像深度预测任务的发展。在未来一个有趣的方向是超越深度图，直接在3D空间处理几何结构化预测问题。]]></content>
      <categories>
        <category>计算机视觉</category>
      </categories>
      <tags>
        <tag>planenet</tag>
        <tag>平面重建</tag>
        <tag>平面检测</tag>
        <tag>深度图重建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows 使用 VNC 远程连接 Ubuntu 桌面版]]></title>
    <url>%2F2019%2F04%2Fwindows-connect-ubuntu-with-vnc%2F</url>
    <content type="text"><![CDATA[前言工作需要使用 Windows 远程桌面版的 Ubuntu，原来使用的 TeamViewer 现在经常被检测为商业用途，就很麻烦。因此，现在转战使用 VNC 进行远程。使用步骤参考地址：法号阿兴，下面是自己的记录，以备不时之需。 使用步骤1. 设置 Ubuntu 的桌面共享首先在 Ubuntu 系统中找到桌面共享的应用，如下图：设置远程相关的选项，如：允许远程控制此电脑，远程连接此电脑的时候不需要进行确认，远程连接此电脑的时候需要输入的密码等，如下图： 2. 安装 VNC Server 和 dconf-editor 并设置远程权限打开终端，输入如下命令安装 VNC Server ：1sudo apt-get install xrdp vnc4server xbase-clients Ubuntu 的 dconf 类似于 Windows 下的注册表，有 Ubuntu 系统的相关配置。dconf-editor 就是调整相关配置的一个工具。打开终端，输入如下命令安装 dconf-editor ：1sudo apt-get install dconf-editor 安装完成后打开此工具，依次进入菜单：org --- gnome --- desktop --- remote-access，然后取消 require-encryption（请求加密）的勾选状态，保存设置。如下图：至此 Ubuntu 桌面系统的 VNC Server 设置告一段落。 3. Windows 远程连接 Ubuntu可以通过在 Windows 系统上安装 VNC Viewer 客户端来远程 Ubuntu 桌面系统，下载地址，注意下载对应的Standalone 免安装版本。下载完成就可以打开下载的 VNC Viewer 客户端输入 VNC Server address（即Ubuntu 端的 IP 地址）进行远程连接了，如下图：连接成功就可以看到 Ubuntu 的桌面了。除了使用 VNC Viewer 客户端来远程 Ubuntu 桌面系统，还可以使用 Windows 自带的远程桌面连接应用进行连接，同样是输入服务端的 IP 地址。通过 Windows键+R键 打开运行界面输入 mstsc 即可打开远程桌面应用，如下图：或者通过 Windows键 搜索远程连接应用打开也可，界面显示如下图：输入 IP 以后会转到下图界面，选择模式：vnc-any，输入对应的 IP 和密码即可连接。]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>windows</tag>
        <tag>vnc</tag>
        <tag>远程连接</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows 10 安装 Anaconda3 & GPU版Tensorflow & Cuda9 & cudnn7]]></title>
    <url>%2F2018%2F10%2Fwindows-install-tensorflow-gpu%2F</url>
    <content type="text"><![CDATA[前言为了更好的学习工作，清理了下电脑，重做了下系统，因此需要重新装深度学习相关的运行环境。在这里记录一下安装过程，以备后用。环境：Windows 10 &amp; vs-2015 &amp; cuda9 &amp; cudnn7 &amp; anaconda3 &amp; tensorflow-gpu 安装步骤1. 安装 vs2015首先在安装 cuda 之前需要安装 vs，在这选择安装 vs2015，安装需要的 iso 文件在我的网盘里。 网盘链接：https://pan.baidu.com/s/10KQn-1yBqZ1vzkJnbzNL2A提取码：1aiq 下载完成之后，打开其中的 vs_community.exe 文件进行安装，安装期间所有的选项均默认即可。安装路径也可以单独指定。如果之前电脑里有 vs 的可以直接跳过此步骤，或者可以重新更新一下。 2. 安装 cuda9.0安装完 vs2015 之后就可以安装 cuda 了，在这里我安装的是 cuda9.0 (因为目前 tensorflow 还不支持最新的 cuda10)，cuda9.0 安装文件的下载路径：cuda9.0 安装文件，当然，如果想下载 cuda 的其他可用版本也是可以的。cuda9.0 的安装文件下载好了以后会是类似于：cuda_9.0.176_win10.exe 的一个文件，然后就是打开安装文件，一步步的按照默认的选项进行安装。使用安装文件安装完成之后，打开 cmd命令窗口 输入：1&gt; nvcc -V 就可以看到类似的以下 cuda9.0 的版本信息：1234nvcc: NVIDIA (R) Cuda compiler driverCopyright (c) 2005-2017 NVIDIA CorporationBuilt on Fri_Sep__1_21:08:32_Central_Daylight_Time_2017Cuda compilation tools, release 9.0, V9.0.176 到此，cuda9.0 算是安装完成。 3. 安装 cudnn7安装好 cuda9.0 之后，需要安装与之版本相对应的性能优化库：cudnn7，cudnn7 的下载路径：下载 cudnn7，NVIDIA要求用户登录之后才开放下载 cudnn7 的下载通道，不想登录下载的可以去我的网盘下载。 网盘链接：https://pan.baidu.com/s/1FUl4xEvt-SFeE3saso6-xw提取码：p55p这个版本的 cudnn7 是针对 cuda9.0 的 这是一个压缩包文件，下载好之后解压会出现一个 cuda 文件夹，将文件夹中的东西复制到 NVIDIA GPU Computing Toolkit 的安装路径下。路径默认会在：C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v9.0，复制完成，cudnn 也算安装完成了。 4. 安装 anaconda3gpu 的相关软件设置安装完成，下面就是安装代码所需要的 python 环境了。Anaconda 是一个开源的 python发行版本，其中包括了许多常用的 python 第三方库，相对于传统的 python2&amp;python3 个人感觉更为方便，所以在这里 python 环境使用了 anaconda3 ，默认 python 版本是 3.6 。anaconda3 安装文件的下载路径：下载 anaconda，可能一部分网络在下载的时候会很慢，所以我也放上我的网盘链接： 链接：https://pan.baidu.com/s/15MSq0irNJ9HgVEPRftQy7A提取码：23gv 下载完成之后，打开安装文件，一步步的按照默认选项进行安装，也可以自定义安装路径。安装完成之后按下 Windows键，就能再软件列表看到安装好的 Anaconda3 的相关信息了。 5. 安装 tensorflow-gpu按下 Windows键，在 Anaconda3 的列表下找到 Anaconda Prompt ,点击就会出现 anaconda 环境下的命令行窗口，在这里使用命令1&gt; pip install tensorflow-gpu 即可安装最新版本的 tensorflow-gpu ，成功安装之后，使用以下命令进行检验：123456&gt; pythonPython 3.6.5 |Anaconda, Inc.| (default, Mar 29 2018, 13:32:41) [MSC v.1900 64 bit (AMD64)] on win32Type "help", "copyright", "credits" or "license" for more information.&gt;&gt;&gt; import tensorflow as tf&gt;&gt;&gt; print(tf.__version__)1.11.0 可以成功的导入，并输出 tensorflow-gpu 的相关版本信息就算安装成功了。 问题如果在导入 tensorflow 的过程中出现下面的错误：1ImportError: DLL load failed: 找不到指定的模块 可以尝试重新安装 cuda9.0 和 cudnn7，即能解决问题。 如果在导入 tensorflow 的过程中出现下面的错误：1ModuleNotFoundError: No module named &apos;absl&apos; 可以通过执行下面命令重新安装 absl-py 库来解决问题。12&gt; pip uninstall absl-py&gt; pip install absl-py]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>cuda</tag>
        <tag>cudnn</tag>
        <tag>windows</tag>
        <tag>anaconda</tag>
        <tag>tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu16.04 下 Python3 虚拟环境安装 OpenCV]]></title>
    <url>%2F2018%2F10%2Fubuntu-install-python3-opencv%2F</url>
    <content type="text"><![CDATA[前言最近在看 Light Head Rcnn 的 Tensorflow 源码，在 Python3 下需要用到 OpenCV ，鉴于我的 Ubuntu 下已经装了 Python2.7 的 OpenCV2.4.13.7 点击查看安装教程。所以这次在虚拟环境下配置一下 Python3 的 OpenCV，按照以下步骤直接装了最新的 OpenCV4.0.0-pre。 安装步骤1. 各种依赖包的安装升级一些预安装的软件包：12$ sudo apt-get update$ sudo apt-get upgrade 安装一些编译 OpenCV 所需要的开发工具：1$ sudo apt-get install build-essential cmake git pkg-config 安装一些用于从磁盘中读取各种图片格式所需要的依赖包：1$ sudo apt-get install libjpeg8-dev libtiff4-dev libjasper-dev libpng12-dev 安装一些用于从磁盘中读取视频所需要的依赖包：1$ sudo apt-get install libavcodec-dev libavformat-dev libswscale-dev libv4l-dev 安装以后使用 OpenCV 的 GUI 时所需要的 GTK：1$ sudo apt-get install libgtk2.0-dev 安装用于优化 OpenCV 内部各种功能的依赖包，例如矩阵操作：1$ sudo apt-get install libatlas-base-dev gfortran 2. 设置 Python3 的相关操作首先安装 Python 的包管理工具 pip。安装 Python3 的 pip ：12$ wget https://bootstrap.pypa.io/get-pip.py$ sudo python3 get-pip.py 注意： 在安装 pip 的时候使用的是 python3，如果不用 python3 的话，默认安装的将是 python2 的。 本文前言中说了：是在虚拟环境下安装 Python3 的 OpenCV。所以在这里搭建 Python3 的虚拟环境需要用到 virtualenv 和 virtualenvwrapper ，下面先使用 pip 安装 virtualenv 和 virtualenvwrapper 。1$ sudo pip3 install virtualenv virtualenvwrapper 注意： 在这里使用的也是 pip3 ，而不是 pip ，使用 pip3 安装确保将这两个包装在 Python3 的环境下。 下面就要更新环境变量了，在 ~/.bashrc 文件的最后添加上以下环境变量信息：1234# virtualenv and virtualenvwrapperexport VIRTUALENVWRAPPER_PYTHON=/usr/bin/python3export WORKON_HOME=$HOME/.virtualenvssource /usr/local/bin/virtualenvwrapper.sh 注意一下在这里是怎么将 VIRTUALENVWRAPPER_PYTHON 指向 Python3 所在的 Ubuntu 系统路径的。 为了确保刚刚配置的环境变量有效，执行以下命令：1$ source ~/.bashrc 然后，创建下面安装 Python3 的 OpenCV 需要使用 cv 虚拟环境：1$ mkvirtualenv cv 这时可以看到终端中用户名的前面有了 (cv) 的标识。目前算是完成了 Python 设置的一半了，下面需要安装 Python3 的开发文件：1$ sudo apt-get install python3.5-dev 我这里的 Python3 的版本是 3.5 ，所以我装的是 python3.5-dev。OpenCV 还需要用到 Numpy ，下一步安装 Numpy ：1$ pip install numpy 注意： 这一步出错的朋友请移步本文开头的参考链接，那里有解决方案。 3. 安装 OpenCV到此，安装 OpenCV 所需要设置的环境都设置完毕，下面开始下载 OpenCV 的源码：1$ git clone https://github.com/Itseez/opencv.git 注意： 本文开头的参考文章中有安装 OpenCV 的 contrib库 ，目前我还用不到，所以就不占用那个空间去装了，需要的还请移步自取。 下载好源码以后就是编译了：1234$ cd opencv$ mkdir release$ cd release$ cmake -D CMAKE_BUILD_TYPE=RELEASE -D CMAKE_INSTALL_PREFIX=/usr/local -D INSTALL_C_EXAMPLES=ON -D INSTALL_PYTHON_EXAMPLES=ON -D BUILD_EXAMPLES=ON .. cmake 命令结束以后就可以看到以下 python3 的信息了：注意： 在 cmake 以后看到 python3 的信息才能进行下面的操作。 下面开始 OpenCV 的编译操作：1$ make -j4 注意： 上述命令中的 4 根据处理器的内核数来设置，可以加快编译速度。 在编译的时候遇到错误：12fatal error: Eigen/Eigenvalues: No such file or directorycompilation terminated. 解决方法：重新 cmake ，在 cmake 的时候加入参数 -D WITH_EIGEN=OFF，然后重新编译就通过了。 在没有报错编译完成之后，可以执行下列命令将 OpenCV 装到系统里：12$ sudo make install$ sudo ldconfig 4. 设置 OpenCV 的系统链接在没有错误的情况下执行完以上步骤，执行命令：1$ ls -l /usr/local/lib/python3.5/site-packages/ 就可以看到 OpenCV 的相关信息了：在这里 OpenCV 的名字是 cv2.cpython-35m-x86_64-linux-gnu.so 。下面为了能在创建的 cv 虚拟环境中使用 OpenCV ，需要将这个 site-packages 文件夹下的 cv2.cpython-35m-x86_64-linux-gnu.so 文件链接到 cv 虚拟环境中：12$ cd ~/.virtualenvs/cv/lib/python3.5/site-packages/$ ln -s /usr/local/lib/python3.5/site-packages/cv2.cpython-35m-x86_64-linux-gnu.so cv2.so 在上述命令中将 cv2.cpython-35m-x86_64-linux-gnu.so 的名字改成了 cv2.so，这样在 Python3 中就能直接导入 cv2 了。这时候使用 ls 命令就可以看到 cv2.so 文件了。如果没有 cv2.so 文件，将不能导入 cv2 。 5. 测试 Python3 安装的 OpenCV打开终端，进入创建的 cv 虚拟环境，在 Python 中导入 cv2 查看 OpenCV 的版本：12345$ workon cv$ python&gt;&gt;&gt; import cv2&gt;&gt;&gt; cv2.__version__'4.0.0-pre' 结束，安装成功。 参考：https://www.pyimagesearch.com/2015/07/20/install-opencv-3-0-and-python-3-4-on-ubuntu/]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>python3</tag>
        <tag>opencv</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows 10 安装 Desktop Ubuntu]]></title>
    <url>%2F2018%2F10%2Fwindows10-install-desktop-ubuntu%2F</url>
    <content type="text"><![CDATA[前言前一段时间在 Windows 10 上装了 Bash 的 Ubuntu ，所以就想是不是也能装 Desktop 版本的。经过一番搜索，果断找到了。下面记录下过程： 安装前提 新版本的 Windows 10（装有Windows Subsystem for Linux） 提前装了 Bash 版本的 Ubuntu 安装步骤可以参考：Windows 10 安装 Bash Ubuntu 下载 windows 下的 X-service下载地址：https://sourceforge.net/projects/vcxsrv/下载好，安装好以后，打开 XLaunch ，首次使用会弹出设置窗口，选择 One large window，设置 Display number 为 0 ，如下图下面其余的设置全部按默认走。 在 Bash 版本 Ubuntu 里下载桌面12$ sudo apt-get update$ sudo apt-get install ubuntu-desktop unity compiz-core compizconfig-settings-manager 会下载六百多M的包，解压完有两个多G。 注：在下载过程中网络要绝对的稳定，不然很容易卡着不动。卡着不动了不要惊慌，不要失措，可以选择继续等（经过一段时间有可能会再次动起来），也可以选择干掉重新来过。 配置 compiz 窗口管理器启动刚才安装的 XLaunch ，然后在 Bash 版的 Ubuntu 中执行命令：12$ export DISPLAY=localhost:0$ sudo ccsm 然后在打开的 XLaunch 界面会出现 ccsm 的配置界面，勾选 Ubuntu Unity Plugin 选项，其余的默认就行不用管。然后关闭 ccsm ，关闭的时候会弹出几个窗口全部选确定。在 Bash 版的 Ubuntu 中执行命令：1$ sudo compiz 看启动的 XLaunch 界面就会出现 Ubuntu 的 Desktop 界面了。 转载自：https://blog.csdn.net/u011138447/article/details/78262369?locationNum=4&amp;fps=1]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>desktop ubuntu</tag>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows 10 安装 Bash Ubuntu]]></title>
    <url>%2F2018%2F10%2Fwindows10-install-bash-ubuntu%2F</url>
    <content type="text"><![CDATA[前言听闻微软大哥在新版本的 Windows 10 里添加了个新功能，可以直接在 Windows 10 下直接安装使用 Bash 版本的 Ubuntu 。 安装前提 新版本的 64位的Windows 10（装有Windows Subsystem for Linux） 安装 Ubuntu打开 win10 的 Windows 设置，如下图在 查找设置 输入框输入 Windows 功能 会出现 启用或关闭 Windows 功能，如下图点击进入会出现 Windows 功能窗口，勾选 适用于 Linux 的 Windows 子系统。如下图然后打开微软应用商店，如下图搜索 Ubuntu，点击安装。如下图安装完成后就可以在应用列表搜索 Ubuntu 找到安装好的 Bash 版 Ubuntu ，点击就可以开始使用了。如下图首次使用会让你设置 username 和 password 。以后使用效果如下图：完。]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>bash ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 博客绑定个人域名]]></title>
    <url>%2F2018%2F07%2Fcustom-domain%2F</url>
    <content type="text"><![CDATA[前段时间用 hexo 搭建的 gitpage 个人博客，服务器用的是 github 的，然后域名默认也是 github 下的二级域名：username.github.io, 现在为了提升格调准备将自己的博客指向一个新的域名。下面记录下过程。 购买域名国内的域名服务商有新网，腾讯云，还有阿里云的万网等。下面以阿里云的万网为例： 在万网购买了自己心仪的域名后，进入阿里云的管理控制台-域名与网站-域名就可以看到购买的域名此时的域名状态是未实名认证的，然后就是实名认证（一般需要2小时左右）。 域名解析首先获取自己 github 的二级域名的 IP地址，windows 下直接在 cmd 里 Ping 一下自己的博客就会得到 IP 地址：下面通过 DNS域名解析将购买的域名指向 github 的二级域名：username.github.io，进入阿里云的管理控制台-域名与网站-云解析 DNS，进入域名的解析设置，点击新手指导，将得到的 IP 地址填到记录值一栏，点击确定就 OK 了。填完以后的解析列表会出现：记录值就是自己 github 的二级域名的 IP地址。 设置CNAME在 hexo 项目下，source 文件夹下面创建 CNAME 文件（没有后缀名的），在里面写上购买的域名。比如： 在 github 上面，打开 username.github.io 项目的（Settings）设置，然后在 GitHub Pages的 Custom domain设置里填上购买的域名。比如： 好了，新域名配置完成，可以访问了。]]></content>
      <categories>
        <category>博客技术</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>绑定域名</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 的 Next 主题中渲染 MathJax 数学公式]]></title>
    <url>%2F2018%2F07%2Fmathjax-in-hexo%2F</url>
    <content type="text"><![CDATA[在用markdown写技术文档时，免不了会碰到数学公式。常用的Markdown编辑器都会集成Mathjax，用来渲染文档中的类Latex格式书写的数学公式。基于Hexo搭建的个人博客，默认情况下渲染数学公式却会出现各种各样的问题。 这个问题搞了好久才找到解决方案，感谢@小毛驴 原因Hexo 默认使用 ”hexo-renderer-marked” 引擎渲染网页，该引擎会把一些特殊的 markdown 符号转换为相应的 html 标签，比如在 markdown 语法中，下划线_代表斜体，会被渲染引擎处理为&lt;em&gt;标签。 因为类 Latex 格式书写的数学公式下划线_表示下标，有特殊的含义，如果被强制转换为&lt;em&gt;标签，那么 MathJax 引擎在渲染数学公式的时候就会出错。 类似的语义冲突的符号还包括*, {, }, \\等。 解决方法更换 Hexo 的 markdown 渲染引擎，hexo-renderer-kramed 引擎是在默认的渲染引擎 hexo-renderer-marked 的基础上修改了一些 bug ，两者比较接近，也比较轻量级。12$ npm uninstall hexo-renderer-marked --save$ npm install hexo-renderer-kramed --save 执行上面的命令即可，先卸载原来的渲染引擎，再安装新的。然后，跟换引擎后行间公式可以正确渲染了，但是这样还没有完全解决问题，行内公式的渲染还是有问题，因为 hexo-renderer-kramed 引擎也有语义冲突的问题。接下来到博客根目录下，找到node_modules\kramed\lib\rules\inline.js，把第11行的 escape 变量的值做相应的修改：12//escape: /^\\([\\`*&#123;&#125;\[\]()#$+\-.!_&gt;])/,escape: /^\\([`*\[\]()#$+\-.!_&gt;])/, 这一步是在原基础上取消了对\\,\{,\}的转义(escape)。同时把第20行的em变量也要做相应的修改。12//em: /^\b_((?:__|[\s\S])+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,em: /^\*((?:\*\*|[\s\S])+?)\*(?!\*)/, 重新启动hexo（先clean再generate）,问题完美解决。哦，如果不幸还没解决的话，看看是不是还需要在使用的主题中配置mathjax开关。 在 Next 主题中开启 MathJax 开关如何使用了主题了，别忘了在主题（Theme）中开启 MathJax 开关，下面以 next 主题为例，介绍下如何打开 MathJax 开关。 进入到主题目录，找到 _config.yml 配置问题，把 math 默认的 false 修改为true，具体如下： 1234567891011# Math Equations Render Supportmath: enable: true # Default(true) will load mathjax/katex script on demand # That is it only render those page who has 'mathjax: true' in Front Matter. # If you set it to false, it will load mathjax/katex srcipt EVERY PAGE. per_page: true engine: mathjax #engine: katex 还需要在文章的Front-matter里打开mathjax开关，如下：123456---title: index.htmldate: 2018-07-05 12:01:30tags:mathjax: true-- 之所以要在文章头里设置开关，是因为考虑只有在用到公式的页面才加载 Mathjax，这样不需要渲染数学公式的页面的访问速度就不会受到影响了。]]></content>
      <categories>
        <category>博客技术</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>machjax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu16.04 安装 TensorRT]]></title>
    <url>%2F2018%2F06%2Fubuntu-install-tensorrt%2F</url>
    <content type="text"><![CDATA[安装步骤首先下载tar版本的安装包，下载地址需要登陆NVIDIA。安装TensorRT前需要安装Cuda和cudnn，安装步骤可以参考 ubuntu安装cuda和cudnn。打开下载的TensorRT所在路径，解压下载的tar文件：1$ tar -xzvf TensorRT-XXX.tar.gz 解压好添加环境变量：1234567$ vim ~/.bashrc # 打开环境变量文件# 将下面三个环境变量写入环境变量文件并保存export LD_LIBRARY_PATH=TensorRT解压路径/lib:$LD_LIBRARY_PATHexport CUDA_INSTALL_DIR=/usr/local/cuda-9.0export CUDNN_INSTALL_DIR=/usr/local/cuda-9.0# 使刚刚修改的环境变量文件生效$ source ~/.bashrc 下面是安装Python的TensorRT包：进到解压的TensorRT目录下的Python目录：1234# 对于python2$ sudo pip2 install tensorrt-XXX-cp27-cp27mu-linux_x86_64.whl# 对于python3$ sudo pip3 install tensorrt-XXX-cp35-cp35m-linux_x86_64.whl 如安装失败请参考文章末尾的解决方案。测试TensorRT是否安装成功，进入Python编辑器加载tensorrt：12&gt;&gt;&gt; import tensorrt&gt;&gt;&gt; tensorrt.__version__ 会输出TensorRT的版本号，即安装成功。然后转到uff目录下安装uff包：1234# 对于python2$ sudo pip2 install uff-0.1.0rc0-py2.py3-none-any.whl# 对于python3$ sudo pip3 install uff-0.1.0rc0-py2.py3-none-any.whl 测试：1$ which convert-to-uff 会输出uff的安装路径。拷贝lenet5.uff到python相关目录进行验证：123456$ sudo cp TensorRT-XXX/data/mnist/lenet5.uff TensorRT-XXX/python/data/mnist/lenet5.uff$ cd TensorRT-XXX/samples/sampleMNIST$ make clean$ make$ cd /TensorRT-XXX/bin（转到bin目录下面，make后的可执行文件在此目录下）$ ./sample_mnist 命令执行顺利即安装成功。 错误在安装Python的TensorRT包时可能出现的错误：1234In file included from src/cpp/cuda.cpp:1:0: src/cpp/cuda.hpp:14:18: fatal error: cuda.h: No such file or directory compilation terminated. error: command 'x86_64-linux-gnu-gcc' failed with exit status 1 原因显示是找不到cuda.h，根据网上分析是因为用了sudo之后环境变量用的是root的环境变量。参考 解决方案将cuda的安装路径添加到root的环境变量中，在root角色下安装Python的TensorRT包12345$ sudo vim /etc/profile.d/cuda.sh添加：export PATH=/usr/local/cuda-9.0/bin:$PATH$ sudo su -$ pip2 install tensorrt-XXX-cp27-cp27mu-linux_x86_64.whl $ exit 参考：https://blog.csdn.net/xll_bit/article/details/78376320]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>cuda</tag>
        <tag>cudnn</tag>
        <tag>tensorrt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu 系统查询 cuda 和 cudnn 版本号]]></title>
    <url>%2F2018%2F06%2Fubuntu-inquire-cuda-and-cudnn-version%2F</url>
    <content type="text"><![CDATA[查询 cuda 版本号命令行输入：1$ cat /usr/local/cuda/version.txt 会输出如下信息：1&gt;&gt;&gt; CUDA Version 8.0.61 显示cuda版本号为：8.0.61 查询 cudnn 版本号命令行输入：1$ cat /usr/local/cuda/include/cudnn.h | grep CUDNN_MAJOR -A 2 会输出如下信息：123456#define CUDNN_MAJOR 7#define CUDNN_MINOR 0#define CUDNN_PATCHLEVEL 1--#define CUDNN_VERSION (CUDNN_MAJOR * 1000 + CUDNN_MINOR * 100 + CUDNN_PATCHLEVEL)#include &quot;driver_types.h&quot; 显示cudnn版本号为：7.0.1]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>cuda</tag>
        <tag>cudnn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu16.04 安装 Caffe]]></title>
    <url>%2F2018%2F06%2Fubuntu-install-caffe%2F</url>
    <content type="text"><![CDATA[安装步骤首先安装各种依赖包：12$ sudo apt-get install libprotobuf-dev libleveldb-dev libsnappy-dev libopencv-dev python-dev libgflags-dev libatlas-base-dev libhdf5-serial-dev protobuf-compiler$ sudo apt-get install --no-install-recommends libboost-all-dev 从github上面拷贝下来caffe项目：12$ git clone https://github.com/BVLC/caffe.git$ cd caffe 安装caffe版的SSD拷贝步骤为：123$ git clone https://github.com/weiliu89/caffe.git$ cd caffe$ git checkout ssd 然后将caffe主目录下面的Makefile.config.example拷贝更名为Makefile.config，打开操作：12$ cp Makefile.config.example Makefile.config$ gedit Makefile.config 将其中的：1234#USE_CUDNN := 1#WITH_PYTHON_LAYER := 1INCLUDE_DIRS := $(PYTHON_INCLUDE) /usr/local/includeLIBRARY_DIRS := $(PYTHON_LIB) /usr/local/lib /usr/lib 分别更改为：1234USE_CUDNN := 1WITH_PYTHON_LAYER := 1INCLUDE_DIRS := $(PYTHON_INCLUDE) /usr/local/include /usr/include/hdf5/serialLIBRARY_DIRS := $(PYTHON_LIB) /usr/local/lib /usr/lib /usr/lib/x86_64-linux-gnu /usr/lib/x86_64-linux-gnu/hdf5/serial 打开 Makefile文件：1$ gedit Makefile 将其中的：1NVCCFLAGS += -ccbin=$(CXX) -Xcompiler-fPIC $(COMMON_FLAGS) 更改为：1NVCCFLAGS += -D_FORCE_INLINES -ccbin=$(CXX) -Xcompiler -fPIC $(COMMON_FLAGS) 打开/usr/local/cuda/include/crt/host_config.h文件：1$ sudo gedit /usr/local/cuda/include/crt/host_config.h 将其中的：1#error-- unsupported GNU version! gcc versions later than 4.9 are not supported! 更改为：1//#error-- unsupported GNU version! gcc versions later than 4.9 are not supported! 下面就是编译caffe并测试：123$ make clean -j8$ make all -j8 $ make runtest -j8 最后输出PASS说明测试成功。配置环境变量：1$ vim ~/.bashrc 在文件末尾写入caffe-pathon的安装路径：1export PYTHONPATH=caffe安装路径/caffe/python:$PYTHONPATH 上述语句中的~表示caffe所在的根目录。是环境变量生效：1$ source ~/.bashrc 然后执行：1$ make pycaffe 常见问题CUDA9错误12345NVCC src/caffe/layers/bnll_layer.cunvcc fatal : Unsupported gpu architecture 'compute_20'Makefile:594: recipe for target '.build_release/cuda/src/caffe/layers/bnll_layer.o' failedmake: *** [.build_release/cuda/src/caffe/layers/bnll_layer.o] Error 1make: *** Waiting for unfinished jobs.... 解决方案cuda9不支持‘ compute-20 ’，需要修改Makefile.config文件中CUDA_ARCH设置，将12345678910111213# CUDA architecture setting: going with all of them.# For CUDA &lt; 6.0, comment the *_50 through *_61 lines for compatibility.# For CUDA &lt; 8.0, comment the *_60 and *_61 lines for compatibility.# For CUDA &gt;= 9.0, comment the *_20 and *_21 lines for compatibility.CUDA_ARCH := -gencode arch=compute_20,code=sm_20 \ -gencode arch=compute_20,code=sm_21 \ -gencode arch=compute_30,code=sm_30 \ -gencode arch=compute_35,code=sm_35 \ -gencode arch=compute_50,code=sm_50 \ -gencode arch=compute_52,code=sm_52 \ -gencode arch=compute_60,code=sm_60 \ -gencode arch=compute_61,code=sm_61 \ -gencode arch=compute_61,code=compute_61 中的12-gencode arch=compute_20,code=sm_20 \-gencode arch=compute_20,code=sm_21 \ 删除即可重新编译。 HDF5错误1234src/caffe/net.cpp:8:18: fatal error: hdf5.h: No such file or directorycompilation terminated.Makefile:581: recipe for target '.build_release/src/caffe/net.o' failedmake: *** [.build_release/src/caffe/net.o] Error 1 或者1234567AR -o .build_release/lib/libcaffe.aLD -o .build_release/lib/libcaffe.so.1.0.0/usr/bin/ld: cannot find -lhdf5_hl/usr/bin/ld: cannot find -lhdf5collect2: error: ld returned 1 exit statusMakefile:572: recipe for target '.build_release/lib/libcaffe.so.1.0.0' failedmake: *** [.build_release/lib/libcaffe.so.1.0.0] Error 1 解决方案执行命令安装libhdf5-dev1$ sudo apt-get install libhdf5-dev 然后再重新编译。 gflags错误12345In file included from src/caffe/net.cpp:10:0:./include/caffe/common.hpp:5:27: fatal error: gflags/gflags.h: No such file or directorycompilation terminated.Makefile:581: recipe for target '.build_release/src/caffe/net.o' failedmake: *** [.build_release/src/caffe/net.o] Error 1 解决方案执行命令安装gflags1$ sudo apt-get install libgflags-dev 然后再重新编译。 glog错误12345In file included from src/caffe/net.cpp:10:0:./include/caffe/common.hpp:6:26: fatal error: glog/logging.h: No such file or directorycompilation terminated.Makefile:581: recipe for target '.build_release/src/caffe/net.o' failedmake: *** [.build_release/src/caffe/net.o] Error 1 解决方案执行命令安装glog1$ sudo apt-get install libgoogle-glog-dev 然后再重新编译。 LMDB错误12345In file included from src/caffe/util/db.cpp:3:0:./include/caffe/util/db_lmdb.hpp:8:18: fatal error: lmdb.h: No such file or directorycompilation terminated.Makefile:581: recipe for target '.build_release/src/caffe/util/db.o' failedmake: *** [.build_release/src/caffe/util/db.o] Error 1 解决方案执行命令安装lmdb1$ sudo apt-get install liblmdb-dev 然后再重新编译。 opencv_imgcodecs opencv_videoio错误12345/usr/bin/ld: cannot find -lopencv_imgcodecs/usr/bin/ld: cannot find -lopencv_videoiocollect2: error: ld returned 1 exit statusMakefile:579: recipe for target '.build_release/lib/libcaffe.so.1.0.0-rc5' failedmake: *** [.build_release/lib/libcaffe.so.1.0.0-rc5] Error 1 解决方案打开Makefile文件，在164行（我的文件）加上opencv_imgcodecs，如下：123LIBRARIES += glog gflags protobuf leveldb snappy \ lmdb boost_system hdf5_hl hdf5 m \ opencv_core opencv_highgui opencv_imgproc opencv_imgcodecs 然后再重新编译。 numpy路径错误1234python/caffe/_caffe.cpp:10:31: fatal error: numpy/arrayobject.h: No such file ordirectorycompilation terminated.make: *** [python/caffe/_caffe.so] Error 1` 解决方案打开python编辑器，通过命令得到numpy的安装路径：123&gt;&gt;&gt; import numpy&gt;&gt;&gt; dirs = numpy.get_include()&gt;&gt;&gt; print(dirs) 然后就能看到numpy的安装路径，打开caffe目录下的Makefile.config文件，将65行（我的文件）的路径：/usr/lib/python2.7/dist-packages/numpy/core/include换成刚刚得到numpy的安装路径，然后重新编译。]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>caffe</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu16.04 安装 cuda9 和 cudnn7]]></title>
    <url>%2F2018%2F06%2Fubuntu-install-cuda-and-cudnn%2F</url>
    <content type="text"><![CDATA[安装步骤安装 cuda首先下载 cuda9.0 下载地址的 (runfile) 安装文件，下载完成进到文件下载的目录下，给安装文件赋予权限：1$ sudo chmod 777 XXX.run # XXX为安装文件的文件名 执行安装文件：1$ sudo sh XXX.run 在看完协议选择 Install NVIDIA Accelerated Graphics Driver for nvidia 时，选择 no，其他的可全部选择 yes 和默认回车；并且在查看协议时有快捷键 Ctrl+D 进行翻页。下面安装完成配置环境变量：打开环境变量文件1$ gedit ~/.bashrc 在文件末尾加上安装的 cuda9.0 路径12export PATH=/usr/local/cuda-9.0/bin:$PATHexport LD_LIBRARY_PATH=/usr/local/cuda-9.0/lib64:$LD_LIBRARY_PATH 配置完环境变量，使其生效：1$ source ~/.bashrc 然后进行测试：123$ cd /usr/local/cuda-9.0/samples/1_Utilities/deviceQuery$ sudo make$ sudo ./deviceQuery 测试结果有输出PASS，即为正确安装。 安装 cudnn首先下载 cudnn7 下载路径（下载 cudnn7 需要登陆 NVIDIA ，没有 NVIDIA 账号的注册一个就行了。）下载 tgz 压缩文件。首先解压 tgz 压缩文件：1$ tar -xzvf cudnn-XXX.tgz 接着复制文件到 cuda 路径下：123$ sudo cp cuda/include/cudnn.h /usr/local/cuda/include$ sudo cp cuda/lib64/libcudnn* /usr/local/cuda/lib64$ sudo chmod a+r /usr/local/cuda/include/cudnn.h /usr/local/cuda/lib64/libcudnn* 复制完成然后使用命令，可以看到输出相应的 cuda 和 cudnn 的版本信息1$ nvcc -V 如果提示库缺失错误，可参考以下命令：1234$ sudo cp /usr/local/cuda-9.0/lib64/libcudart.so.9.0 /usr/local/lib/libcudart.so.9.0 &amp;&amp; sudo ldconfig$ sudo cp /usr/local/cuda-9.0/lib64/libcublas.so.9.0 /usr/local/lib/libcublas.so.9.0 &amp;&amp; sudo ldconfig$ sudo cp /usr/local/cuda-9.0/lib64/libcurand.so.9.0 /usr/local/lib/libcurabd.so.9.0 &amp;&amp; sudo ldconfig$ sudo cp /usr/local/cuda-9.0/lib64/libcudnn.so.7 /usr/local/lib/libcudnn.so.7 &amp;&amp; sudo ldconfig]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>cuda</tag>
        <tag>cudnn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu16.04 安装 NVIDIA 驱动]]></title>
    <url>%2F2018%2F06%2Fubuntu-install-nvidia-drive%2F</url>
    <content type="text"><![CDATA[问题描述 在安装了NVIDIA驱动后出现了进入Ubuntu循环登录的问题。 解决方案1.进入命令行界面Ctrl+Alt+F1打开编辑配置文件：1$ vim /etc/modprobe.d/blacklist.conf 在最后一行添加：1blacklist nouveau 2.禁用 nouveau 第三方驱动，之后也不需要改回来执行：12$ sudo update-initramfs -u$ lsmod | grep nouveau 没有输出即屏蔽好了。 3.禁用X服务，执行：1$ sudo /etc/init.d/lightdm stop 4.给驱动run文件赋予执行权限1$ sudo chmod a+x NVIDIA***.run 安装(注意 参数)1$ sudo ./NVIDIA***.run –no-opengl-files 5.启用X服务，执行：1$ sudo /etc/init.d/lightdm stop 如果还无法进入桌面，这是因为驱动修改了xorg的配置，可执行一下命令：12$ cd /usr/share/X11/xorg.conf.d/ $ sudo mv nvidia-drm-outputclass.conf nvidia-drm-outputclass.conf.bak 参考http://blog.csdn.net/u012759136/article/details/53355781]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>nvidia驱动</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu16.04 python2 安装 OpenCV2.4.13.6]]></title>
    <url>%2F2018%2F06%2Fubuntu-install-opencv%2F</url>
    <content type="text"><![CDATA[事先装有 OpenCV 需要重新安装的，先执行卸载步骤，再安装。 卸载步骤1.找到当初安装 OpenCV 的 release 或 build 目录，执行以下命令1234sudo make uninstallcd ..sudo rm -r buildsudo rm -r /usr/local/include/opencv2 /usr/local/include/opencv /usr/include/opencv /usr/include/opencv2 /usr/local/share/opencv /usr/local/share/OpenCV /usr/share/opencv /usr/share/OpenCV /usr/local/bin/opencv* /usr/local/lib/libopencv* 2.删除 usr 文件夹中所有 opencv 相关项12cd /usr/find . -name "*opencv*" | xargs sudo rm -rf 3.移除 Python 相关1apt-get remove opencv-doc opencv-data python-opencv 安装步骤1.通过命令安装各种软件包123$ sudo apt-get install build-essential$ sudo apt-get install cmake git libgtk2.0-dev pkg-config libavcodec-dev libavformat-dev libswscale-dev$ sudo apt-get install python-dev python-numpy libtbb2 libtbb-dev libjpeg-dev libpng-dev libtiff-dev libjasper-dev libdc1394-22-dev 2.进到安装路径下拷贝 OpenCV 源码1$ git clone https://github.com/opencv/opencv.git 3.选择安装的 OpenCV 版本号12$ cd opencv$ git checkout -b 2.4 origin/2.4 4.使用 Cmake 编译 OpenCV 源码123$ mkdir release$ cd release$ cmake -D CMAKE_BUILD_TYPE=RELEASE -D CMAKE_INSTALL_PREFIX=/usr/local .. 5.make 安装 OpenCV12$ make -j4$ sudo make install 安装到此结束。 测试命令进入 Python 编辑器12&gt;&gt;&gt; import cv2&gt;&gt;&gt; print(cv2.__version__) 会输出 OpenCV 的版本号。 cuda 9.0 与 opencv 版本匹配问题：Cmake 过程中会出现以下问题： 错误123CMake Error: The following variables are used in this project, but they are set to NOTFOUND.Please set them or make sure they are set and tested correctly in the CMake files:CUDA_nppi_LIBRARY (ADVANCED) 原因在cuda9里面，NVIDIA把 libnppi.so换成libnppc.so libnppial.so libnppicc.so libnppicom.so libnppidei.so libnppif.so libnppig.so libnppim.so libnppist.so libnppisu.so libnppitc.so libnpps.so 解决方案修改opencv/cmake/FindCUDA.cmake 文件，将其中的1unset(CUDA_nppi_LIBRARY CACHE) 替换为：12345678910unset(CUDA_nppial_LIBRARY CACHE)unset(CUDA_nppicc_LIBRARY CACHE)unset(CUDA_nppicom_LIBRARY CACHE)unset(CUDA_nppidei_LIBRARY CACHE)unset(CUDA_nppif_LIBRARY CACHE)unset(CUDA_nppig_LIBRARY CACHE)unset(CUDA_nppim_LIBRARY CACHE)unset(CUDA_nppist_LIBRARY CACHE)unset(CUDA_nppisu_LIBRARY CACHE)unset(CUDA_nppitc_LIBRARY CACHE) 将12find_cuda_helper_libs(nppi)set(CUDA_npp_LIBRARY"$&#123;CUDA_nppc_LIBRARY&#125;;$&#123;CUDA_nppi_LIBRARY&#125;;$&#123;CUDA_npps_LIBRARY&#125;") 替换为1234567891011find_cuda_helper_libs(nppial)find_cuda_helper_libs(nppicc)find_cuda_helper_libs(nppicom)find_cuda_helper_libs(nppidei)find_cuda_helper_libs(nppif)find_cuda_helper_libs(nppig)find_cuda_helper_libs(nppim)find_cuda_helper_libs(nppist)find_cuda_helper_libs(nppisu)find_cuda_helper_libs(nppitc)set(CUDA_npp_LIBRARY "$&#123;CUDA_nppc_LIBRARY&#125;;$&#123;CUDA_nppial_LIBRARY&#125;;$&#123;CUDA_nppicc_LIBRARY&#125;;$&#123;CUDA_nppicom_LIBRARY&#125;;$&#123;CUDA_nppidei_LIBRARY&#125;;$&#123;CUDA_nppif_LIBRARY&#125;;$&#123;CUDA_nppig_LIBRARY&#125;;$&#123;CUDA_nppim_LIBRARY&#125;;$&#123;CUDA_nppist_LIBRARY&#125;;$&#123;CUDA_nppisu_LIBRARY&#125;;$&#123;CUDA_nppitc_LIBRARY&#125;;$&#123;CUDA_npps_LIBRARY&#125;") 错误1opencv nvcc fatal : Unsupported gpu architecture 'compute_20' 原因cuda9不支持‘ compute-20 ’ 解决方案：更改 OpenCVDetectCUDA.cmake 文件，把有关 ‘ compute-20 ’ 的全删掉将1234567if(CUDA_GENERATION STREQUAL "Fermi") set(__cuda_arch_bin "3.0 3.5") elseif(CUDA_GENERATION STREQUAL "Kepler") if($&#123;CUDA_VERSION&#125; VERSION_LESS "5.0") set(__cuda_arch_bin "2.0 2.1") else() set(__cuda_arch_bin "3.0 3.5") 替换为1234567if(CUDA_GENERATION STREQUAL "Fermi") set(__cuda_arch_bin "3.0 3.5") elseif(CUDA_GENERATION STREQUAL "Kepler") if($&#123;CUDA_VERSION&#125; VERSION_LESS "5.0") set(__cuda_arch_bin "3.0") else() set(__cuda_arch_bin "3.0 3.5") 将：1234if($&#123;CUDA_VERSION&#125; VERSION_LESS "5.0") set(__cuda_arch_bin "1.1 1.2 1.3 2.0 2.1(2.0) 3.0")elseif($&#123;CUDA_VERSION&#125; VERSION_GREATER "6.5") set(__cuda_arch_bin "2.0 2.1(2.0) 3.0 3.5") 替换为：1234if($&#123;CUDA_VERSION&#125; VERSION_LESS "5.0") set(__cuda_arch_bin "1.1 1.2 1.3 2.0 2.1(2.0) 3.0")elseif($&#123;CUDA_VERSION&#125; VERSION_GREATER "6.5") set(__cuda_arch_bin "3.0 3.5") 然后 cmake 成功。 参考https://docs.opencv.org/2.4/doc/tutorials/introduction/linux_install/linux_install.html https://stackoverflow.com/questions/46584000/cmake-error-variables-are-set-to-notfound]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>cuda</tag>
        <tag>OpenCV</tag>
      </tags>
  </entry>
</search>
